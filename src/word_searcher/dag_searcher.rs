use super::{
    embedded_wordlist_iter, iter_to_wordmap, path_to_iter, str_to_set, AlphaMultiset, WordSearcher,
};
use crate::Word;
use fixedbitset::FixedBitSet;
use petgraph::prelude::*;
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

static EMBEDDED_DAG: &'static [u8] = include_bytes!("dag.bin");

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DAGSearcher {
    // NOTE: rolling own DiGraph barely saves any space
    dag: DiGraph<(AlphaMultiset, Vec<Word>), ()>,
}

impl Default for DAGSearcher {
    fn default() -> Self {
        Self::from_embedded_dag()
    }
}

impl DAGSearcher {
    /// Construct lookup index from a wordlist file
    pub fn from_wordlist<P: AsRef<std::path::Path>>(path: P) -> Self {
        Self {
            dag: build_dag(iter_to_wordmap(path_to_iter(path))),
        }
    }

    pub fn from_embedded_wordlist() -> Self {
        Self {
            dag: build_dag(iter_to_wordmap(embedded_wordlist_iter())),
        }
    }

    /// Use embedded wordlist binary (from "dag.bin" generated by `gen_files`)
    pub fn from_embedded_dag() -> Self {
        bincode::deserialize(EMBEDDED_DAG).unwrap()
    }
}

impl WordSearcher for DAGSearcher {
    fn lookup(&self, word: &str) -> Vec<Word> {
        let norm = str_to_set(word);

        let empty_set_node = NodeIndex::from(0);

        let mut visited = FixedBitSet::with_capacity(self.dag.node_count());
        let mut bfs_queue = std::collections::VecDeque::new();
        let mut found_words = Vec::new();

        bfs_queue.push_back(empty_set_node);

        while let Some(nx) = bfs_queue.pop_front() {
            if visited.contains(nx.index()) {
                continue;
            }
            visited.put(nx.index());

            if norm.has_subset(&self.dag[nx].0) {
                found_words.extend_from_slice(&*self.dag[nx].1);
                bfs_queue.extend(self.dag.neighbors(nx));
            }
        }

        return found_words;
    }
}

/// Build a lookup DAG with special root node at index 0 for easy lookups
fn build_dag(
    mut words: HashMap<AlphaMultiset, Vec<Word>>,
) -> DiGraph<(AlphaMultiset, Vec<Word>), ()> {
    let mut dag = DiGraph::<_, ()>::default();
    let empty_set_node = dag.add_node((AlphaMultiset::new_empty(), Vec::new()));
    let universal_set_node = dag.add_node((AlphaMultiset::new_universal(), Vec::new()));

    // keep track of nodes which have no outgoing edges (sinks), to be connected to the empty set later
    let mut sinks = HashSet::new();

    let mut i = 0;
    while !words.is_empty() {
        if i > 0 && i % 10_000 == 0 {
            println!("Inserted {} words", i);
        }
        i += 1;

        // find a set which is not contained in any other set
        let best = {
            let mut word_iter = words.keys();
            let mut best = word_iter.next().unwrap();
            while let Some(cur) = word_iter.next() {
                if cur.has_subset(best) {
                    best = cur;
                }
            }
            best.clone()
        };

        // finds smallest set that still contain "best"
        let mut visited = FixedBitSet::with_capacity(dag.node_count());
        let mut bfs_queue = std::collections::VecDeque::new();
        let mut containing_nodes = Vec::new();
        bfs_queue.push_back(universal_set_node);

        // search through existing DAG to find smallest sets which still contain "best"
        while let Some(nx) = bfs_queue.pop_front() {
            if visited.contains(nx.index()) {
                continue;
            }
            visited.put(nx.index());

            if !dag.neighbors(nx).any(|ni| dag[ni].0.has_subset(&best)) {
                containing_nodes.push(nx);
            } else {
                bfs_queue.extend(dag.neighbors(nx).filter(|&ni| dag[ni].0.has_subset(&best)));
            }
        }

        // add "best" to DAG
        let new_nx = dag.add_node(words.remove_entry(&best).unwrap());

        // add "best" as potential sink
        sinks.insert(new_nx);

        // connect shortest words found above to "best" node
        for parent in containing_nodes {
            dag.add_edge(parent, new_nx, ());

            // since these nodes have outgoing edges, remove them from sinks
            sinks.remove(&parent);
        }
    }

    // connect empty set node to list of sinks
    for sink in sinks.into_iter() {
        dag.add_edge(sink, empty_set_node, ());
    }

    // finally, reverse graph edges so that it can be searched efficiently
    dag.reverse();

    return dag;
}
